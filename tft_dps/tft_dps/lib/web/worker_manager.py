import asyncio
import multiprocessing as mp
from concurrent.futures import ThreadPoolExecutor
from dataclasses import dataclass

from tft_dps.lib.simulator.sim_runner import SimRunner
from tft_dps.lib.web.app_worker import run_app_worker
from tft_dps.lib.web.job_worker import run_job_worker


@dataclass
class AppWorkerHandle:
    proc: mp.Process
    req: mp.Queue
    resp: mp.Queue


class WorkerManager:
    """
    Spawn web servers
    Assign jobs generated by web servers to job workers
    Return job results from job workers to web servers
    """

    def __init__(
        self,
        handles: list[AppWorkerHandle],
        job_workers: list[mp.Process],
        job_queue: mp.Queue,
        result_queue: mp.Queue,
    ) -> None:
        self.handles = handles

        self.job_workers = job_workers
        self.job_queue = job_queue
        self.result_queue = result_queue

        self.tasks = [
            self._monitor_reqs(),
            self._monitor_results(),
        ]

    @classmethod
    def init(cls, num_apps: int, num_workers: int, runner: SimRunner):
        handles = cls._spawn_app_workers(num_apps, runner)

        job_workers, job_queue, result_queue = cls._spawn_job_workers(
            num_workers, runner
        )

        return cls(handles, job_workers, job_queue, result_queue)

    @classmethod
    def _spawn_app_workers(cls, n: int, runner: SimRunner):
        handles = []
        for idx in range(n):
            req = mp.Queue()
            resp = mp.Queue()
            proc = mp.Process(
                target=run_app_worker,
                name=f"tft_dps_app_worker_{idx}",
                kwargs=dict(
                    req_queue=req,
                    resp_queue=resp,
                    unit_info=runner.units,
                    item_info=runner.items,
                    trait_info=runner.traits,
                ),
            )
            proc.start()

            handles.append(AppWorkerHandle(proc, req, resp))

        return handles

    @classmethod
    def _spawn_job_workers(cls, n: int, runner: SimRunner):
        job_queue = mp.Queue()
        result_queue = mp.Queue()

        procs = []
        for idx in range(n):
            proc = mp.Process(
                target=run_job_worker,
                name=f"tft_dps_job_worker_{idx}",
                kwargs=dict(
                    runner=runner,
                    job_queue=job_queue,
                    result_queue=result_queue,
                ),
            )
            proc.start()
            procs.append(proc)

        return procs, job_queue, result_queue

    def _monitor_reqs(self):
        return asyncio.create_task(self.__monitor_reqs())

    async def __monitor_reqs(self):
        while True:
            did_put = False

            for idx_handle, handle in enumerate(self.handles):
                if handle.req.qsize() > 0:
                    req = handle.req.get()
                    self.job_queue.put(
                        dict(
                            req=req,
                            idx_handle=idx_handle,
                        )
                    )
                    did_put = True

            if not did_put:
                await asyncio.sleep(0.25)

    def _monitor_results(self):
        return asyncio.create_task(self.__monitor_results())

    async def __monitor_results(self):
        loop = asyncio.get_running_loop()
        exec = ThreadPoolExecutor(1)

        while True:
            result = await loop.run_in_executor(exec, self.result_queue.get)
            idx_handle: int = result["idx_handle"]
            self.handles[idx_handle].resp.put(result["resp"])

    def destroy(self):
        for handle in self.handles:
            handle.proc.kill()

        for worker in self.job_workers:
            worker.kill()
