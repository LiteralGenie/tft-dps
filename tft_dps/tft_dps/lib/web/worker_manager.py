import asyncio
import dataclasses
import json
import multiprocessing as mp
from concurrent.futures import ThreadPoolExecutor
from dataclasses import dataclass
from typing import TypedDict
from uuid import uuid4

import loguru

from tft_dps.lib.db import TftDb
from tft_dps.lib.paths import LOG_DIR
from tft_dps.lib.simulator.sim_runner import SimRunner
from tft_dps.lib.simulator.sim_state import SimDamage, SimResult, SimStats
from tft_dps.lib.web.app_worker import run_app_worker
from tft_dps.lib.web.job_worker import (
    BatchInfo,
    SimulateAllRequest,
    SimulateJob,
    SimulateJobResult,
    SimulateRequest,
    run_job_worker,
)

loguru.logger.add(
    LOG_DIR / "manager.log",
    filter=lambda record: record["extra"].get("name") == "mgr",
    rotation="10 MB",
    retention=2,
)
MGR_LOGGER = loguru.logger.bind(name="mgr")


@dataclass
class AppWorkerHandle:
    proc: mp.Process
    req: mp.Queue
    resp: mp.Queue


class SimulateAllBatch(TypedDict):
    req: SimulateAllRequest
    idx_handle: int
    data: list[SimResult | None]
    rem: int


class WorkerManager:
    """
    Spawn web servers
    Assign jobs generated by web servers to job workers
    Return job results from job workers to web servers
    """

    def __init__(
        self,
        handles: list[AppWorkerHandle],
        job_workers: list[mp.Process],
        job_queue: mp.Queue,
        result_queue: mp.Queue,
    ) -> None:
        self.handles = handles

        self.job_workers = job_workers
        self.job_queue = job_queue
        self.result_queue = result_queue

        self.tasks = [
            self._monitor_reqs(),
            self._monitor_results(),
        ]

        self.pending_batches = dict()

    @classmethod
    def init(cls, num_apps: int, num_workers: int, runner: SimRunner):
        handles = cls._spawn_app_workers(num_apps, runner)

        job_workers, job_queue, result_queue = cls._spawn_job_workers(
            num_workers, runner
        )

        return cls(handles, job_workers, job_queue, result_queue)

    @classmethod
    def _spawn_app_workers(cls, n: int, runner: SimRunner):
        handles = []
        for idx in range(n):
            req = mp.Queue()
            resp = mp.Queue()
            proc = mp.Process(
                target=run_app_worker,
                name=f"tft_dps_app_worker_{idx}",
                kwargs=dict(
                    req_queue=req,
                    resp_queue=resp,
                    unit_info=runner.units,
                    item_info=runner.items,
                    trait_info=runner.traits,
                ),
            )
            proc.start()

            handles.append(AppWorkerHandle(proc, req, resp))

        return handles

    @classmethod
    def _spawn_job_workers(cls, n: int, runner: SimRunner):
        job_queue = mp.Queue()
        result_queue = mp.Queue()

        procs = []
        for idx in range(n):
            proc = mp.Process(
                target=run_job_worker,
                name=f"tft_dps_job_worker_{idx}",
                kwargs=dict(
                    runner=runner,
                    job_queue=job_queue,
                    result_queue=result_queue,
                ),
            )
            proc.start()
            procs.append(proc)

        return procs, job_queue, result_queue

    def _monitor_reqs(self):
        return asyncio.create_task(self.__monitor_reqs())

    async def __monitor_reqs(self):
        while True:
            did_put = False

            for idx_handle, handle in enumerate(self.handles):
                if handle.req.qsize() > 0:
                    req: SimulateAllRequest = handle.req.get()

                    match req["type"]:
                        case "simulate_all_request":
                            batch_id = uuid4().hex
                            batch_data: list[SimResult | None] = [
                                None for _ in req["requests"]
                            ]

                            to_generate = []
                            for idx, r in enumerate(req["requests"]):
                                if from_db := _select_result(r):
                                    batch_data[idx] = from_db
                                else:
                                    to_generate.append(
                                        SimulateJob(
                                            type="simulate_job",
                                            batch=BatchInfo(
                                                id=batch_id,
                                                idx=idx,
                                                total=len(req["requests"]),
                                            ),
                                            req=r,
                                        )
                                    )

                            if to_generate:
                                self.pending_batches[batch_id] = SimulateAllBatch(
                                    req=req,
                                    idx_handle=idx_handle,
                                    data=batch_data,
                                    rem=len(to_generate),
                                )

                                for x in to_generate:
                                    self.job_queue.put(x)
                            else:
                                self.handles[idx_handle].resp.put(batch_data)
                        case _:
                            raise Exception(req)

            if not did_put:
                await asyncio.sleep(0.25)

    def _monitor_results(self):
        return asyncio.create_task(self.__monitor_results())

    async def __monitor_results(self):
        loop = asyncio.get_running_loop()
        exec = ThreadPoolExecutor(1)

        while True:
            result: SimulateJobResult = await loop.run_in_executor(
                exec, self.result_queue.get
            )

            match result["type"]:
                case "simulate_job_result":
                    b = result["batch"]
                    pb: SimulateAllBatch = self.pending_batches[b["id"]]
                    pb["data"][b["idx"]] = result["resp"]
                    pb["rem"] -= 1

                    _insert_result(
                        pb["req"]["requests"][b["idx"]],
                        result["resp"],
                    )

                    if pb["rem"] == 0:
                        self.handles[pb["idx_handle"]].resp.put(pb["data"])
                        del self.pending_batches[b["id"]]
                case _:
                    raise Exception(result)

    def destroy(self):
        for handle in self.handles:
            handle.proc.kill()

        for worker in self.job_workers:
            worker.kill()


def _request_to_db_id(req: SimulateRequest):
    parts = [req["id_unit"]]

    parts.append(str(req["stars"]))

    parts.extend(sorted(req["items"]))

    parts.extend(
        [f"{k}|{v}" for k, v in sorted(req["traits"].items(), key=lambda kv: kv[0])]
    )

    return "_".join(parts)


def _select_result(req: SimulateRequest) -> SimResult | None:
    id = _request_to_db_id(req)

    db = TftDb()

    does_exist = bool(
        db.connect().execute("SELECT 1 FROM combo WHERE id = ?", [id]).fetchone()
    )
    if not does_exist:
        return

    dps_query = db.connect().execute(
        """
        SELECT
            type, t, mult, physical, magical, true
        FROM dps
        WHERE id_combo = ?
        ORDER by t ASC
        """,
        [id],
    )
    dps_rows = list(dps_query.fetchall())

    stats_query = db.connect().execute(
        """
        SELECT data
        FROM stats
        WHERE id_combo = ?
        """,
        [id],
    )
    stats = json.loads(stats_query.fetchone()["data"])

    result = SimResult(
        attacks=[
            SimDamage(
                t=r["t"],
                mult=r["mult"],
                physical_damage=r["physical"],
                magical_damage=r["magical"],
                true_damage=r["true"],
            )
            for r in dps_rows
            if r["type"] == "auto"
        ],
        casts=[],
        misc_damage=[],
        initial_stats=SimStats(**stats["initial_stats"]),
        final_stats=SimStats(**stats["final_stats"]),
    )
    return result


def _insert_result(req: SimulateRequest, res: SimResult):
    id = _request_to_db_id(req)

    db = TftDb().connect()

    does_exist = bool(db.execute("SELECT 1 FROM combo WHERE id = ?", [id]).fetchone())
    if does_exist:
        MGR_LOGGER.warning(f"Ignored insertion for duplicate result {req}")
        return

    db.execute("INSERT INTO combo (id) VALUES (?)", [id])

    xss = [
        ("auto", res["attacks"]),
        ("cast", res["casts"]),
        ("misc", res["misc_damage"]),
    ]
    for k, xs in xss:
        for x in xs:
            db.execute(
                """
                INSERT INTO dps (
                    id_combo, type, t, mult, physical, magical, true
                ) VALUES (
                    ?, ?, ?, ?, ?, ?, ?
                )
                """,
                [
                    id,
                    k,
                    x["t"],
                    x["mult"],
                    x["physical_damage"],
                    x["magical_damage"],
                    x["true_damage"],
                ],
            )

    db.execute(
        """
        INSERT INTO stats (
            id_combo, data
        ) VALUES (
            ?, ?
        )
        """,
        [
            id,
            json.dumps(
                dict(
                    initial_stats=dataclasses.asdict(res["initial_stats"]),
                    final_stats=dataclasses.asdict(res["final_stats"]),
                )
            ),
        ],
    )

    db.execute(
        """
        INSERT INTO combo_unit (
            id_combo, unit, stars
        ) VALUES (
            ?, ?, ?
        )""",
        [id, req["id_unit"], req["stars"]],
    )

    items = sorted(req["items"])
    for idx, item in enumerate(items):
        db.execute(
            """
            INSERT INTO combo_item (
                id_combo, item, idx
            ) VALUES (
                ?, ?, ?
            )""",
            [id, item, idx],
        )

    for trait, tier in req["traits"].items():
        db.execute(
            """
            INSERT INTO combo_trait (
                id_combo, trait, tier
            ) VALUES (
                ?, ?, ?
            )""",
            [id, trait, tier],
        )

    db.commit()
