import asyncio
import multiprocessing as mp
from dataclasses import dataclass

from tft_dps.lib.web.app_worker import run_app_worker
from tft_dps.lib.web.job_worker import run_job_worker


@dataclass
class AppWorkerHandle:
    proc: mp.Process
    req: mp.Queue
    resp: mp.Queue


class WorkerManager:
    """
    Spawn web servers
    Assign jobs generated by web servers to job workers
    Return job results from job workers to web servers
    """

    def __init__(
        self,
        handles: list[AppWorkerHandle],
        job_workers: list[mp.Process],
        job_queue: mp.Queue,
        result_queue: mp.Queue,
    ) -> None:
        self.handles = handles

        self.job_workers = job_workers
        self.job_queue = job_queue
        self.result_queue = result_queue

        self._monitor_reqs()
        self._monitor_results()

    @classmethod
    def init(cls, num_apps: int, num_workers: int):
        handles = cls._spawn_app_workers(num_apps)

        job_workers, job_queue, result_queue = cls._spawn_job_workers(num_workers)

        return cls(handles, job_workers, job_queue, result_queue)

    @classmethod
    def _spawn_app_workers(cls, n: int):
        handles = []
        for idx in range(n):
            req = mp.Queue()
            resp = mp.Queue()
            proc = mp.Process(
                target=run_app_worker,
                name=f"tft_dps_app_worker_{idx}",
                kwargs=dict(
                    req_queue=req,
                    resp_queue=resp,
                ),
            )
            proc.start()

            handles.append(AppWorkerHandle(proc, req, resp))

        return handles

    @classmethod
    def _spawn_job_workers(cls, n: int):
        job_queue = mp.Queue()
        result_queue = mp.Queue()

        procs = []
        for idx in range(n):
            proc = mp.Process(
                target=run_job_worker,
                name=f"tft_dps_job_worker_{idx}",
                kwargs=dict(
                    job_queue=job_queue,
                    result_queue=result_queue,
                ),
            )
            proc.start()
            procs.append(proc)

        return procs, job_queue, result_queue

    def _monitor_reqs(self):
        asyncio.create_task(self.__monitor_reqs())

    async def __monitor_reqs(self):
        while True:
            did_put = False

            for idx_handle, handle in enumerate(self.handles):
                if handle.req.qsize() > 0:
                    req = handle.req.get_nowait()
                    self.job_queue.put(
                        dict(
                            req=req,
                            idx_handle=idx_handle,
                        )
                    )
                    did_put = True

            if not did_put:
                await asyncio.sleep(0.25)

    def _monitor_results(self):
        asyncio.create_task(self.__monitor_results())

    async def __monitor_results(self):
        while True:
            job = self.result_queue.get()
            idx_handle: int = job["idx_handle"]
            self.handles[idx_handle].resp.put(job["resp"])
